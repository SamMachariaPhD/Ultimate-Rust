= Rust Fundamentals
Learning Rust Notes
:toc: auto

== Introduction 

* Fundamentals are important in rust.
* System programming language.
* Good for `Safety`, `Concurrency`, and `Speed`.

[quote, Wikipedia CONCURRENCY, https://en.wikipedia.org/wiki/Concurrency_(computer_science)]
In computer science, #concurrency# is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome.

* `Python` can give you safety but not concurrency or speed.
* `C/C++` will give you speed and some concurrency but not safety.

https://github.com/CleanCut/ultimate_rust_crash_course [Github repo for exercises]

== Cargo 

* `Cargo` is a #package manager# for `Rust`. It is used to #search# for, #install# and manage packages that you want to use. It is also a #build system#, the #test runner#, and the #documentation generator#. Similar to _npn_, _pip_, and _make_.

* If you want to quickly create a project called *hello*, you can use the following command: `$ cargo new hello`. When you do `$ tree --noreport hello`, you will notice that the project has been created successfully. A config file `Cargo.toml` and a sorce directory `src` with the RUST `main.rs` file.

[plantuml, format=svg, opts="inline"]
----
hello
|_ Cargo.toml
|_ src
    |_ main.rs
----

[quote, Wikipedia TOML, https://en.wikipedia.org/wiki/TOML]
The name "TOML" is an acronym for "Tom's Obvious, Minimal Language" referring to its creator, Tom Preston-Werner.
TOML is a file format for configuration files. It is intended to be easy to read and write due to obvious semantics which aim to be "minimal", and is designed to map unambiguously to a dictionary. Its specification is open-source, and receives community contributions.

* Build and run your project by running `$ cargo run` within the `<...>.rs` folder. Results stored in `target/debug/hello`.

* It's a lot faster to compile* without debug: `$ cargo run --release`. Results stored in `target/release/hello`

== Variables 

* They start with `let`:

[source, rust]
----
fn main() {
    let bunnies = 2;
}
----

Assigning the type. e.g. 32 bit integer:

[source, rust]
----
fn main() {
    let bunnies: i32 = 4;
}
----

Initializing multiple statements at once: 

[source, rust]
----
fn main() {
    let (bunnies, carrots) = (2, 4);
}
----

* For safety, concurrency, and speed, Rust variables are immutable by default. Unless you chose to make them mutable so that you may change their values later. 
Data that never changes can be shared between multiple threads without loss [pass:q[<u>safety</u>]]. Compiler can do extra optimization on data it knows wont change [pass:q[<u>concurrency</u>]]. Run time can be improved by working with unchanging data [pass:q[<u>speed</u>]].

* To make the value of a variable mutable, add a key word `mut` e.g. 

[source, rust]
----
fn main() {
    let mut bunnies = 2;
    bunnies = 3;
}
----

* If you try to change the value of `bunnies` without making it mutable, you will get an error. Rust error messages are very relevant and helpful. Take time to read through an error message.

* Constants `const` are immutable and stay that way. They are usually in caps aka snake case e.g. `CONST_COEFF`. The type anotation is required e.g. `f64`.  The value must be constant expression that can be determined at compile time. e.g. 

[source, rust]
----
fn main() {
    const BUNNY_FACT: f64 = 4.2;
}
----

* You can place a cont outside a function and use it anywhere you want (global). This is good practice for speed.

== Scope 

* Variables have a scope. This is a place in the code within which they are accessible for use. 
* Variables are accessible within the blocks `{}` they were created in, or everywhere if they were created outside the function braces `{}`.
* Variables can be #shadowed#. You can have the same name with different initialization variables but in different scopes. e.g.

[source, rust]
----
fn main() {
    let bunnies = 2;
    {
        let bunnies = 4;
        println!("{}",bunnies); // prints: 4
    }
    println!("{}",bunnies); // prints: 2
}
----
* Variables can also be shadowed in the same scope. 

[source, rust]
----
fn main(){
    let mut bunnies = 4; // mutable
    let bunnies = bunnies; // now immutable
}
----
* Variables can also be shadowed to another type. Say from string to image. 

== Memory Safety

* Variables must be initialized before use. If you want to initialize on condition, the compiler must be sure that the variable will be initialized at some point. e.g. 
* Here, the compiler is not sure that `bunny` will ever be `true`. This program won't compile.

[source, rust]
----
fn main(){
    let bunny: i32;
    if true{
        bunny = 3;
    }
    println!("{}", bunny);
}
----
* Here, the program will be compiled because `bunny` will be initialized regardless.

[source, rust]
----
fn main(){
    let bunny: i32;
    if true{
        bunny = 3;
    } else{
        bunny = 4;
    }
    println!("{}", bunny);
}
----
* `C` programming would go on to compile.

[source, c]
----
#include <stdio.h>
int main(){
    int bunny;
    printf("%d\n", bunny);
}
----

== Functions 
* Functions are defined using the `fn` key word.

[source, rust]
----
fn do_sth(){
    sth;
}
----
* Type may be included in the function definition. The arrow `->` specifies the return type.

[source, rust]
----
fn do_sth(bunny1: f64, carrot: i64) -> f64 {
    return bunny1*carrot;
}
----
* A return in a function can be done without `return` key word or semicolon `;` - __tail expression__.

[source, rust]
----
fn do_sth(bunny1: f64, carrot: i64) -> f64 {
    bunny1*carrot // tail expression
}
----

* Different types for the same argument are not supported.

== Module System

* You can put functions in a different file, say, `lib.rs` and call them into `main.rs` using the key word `use package::function`. The package name is specified in `Cargo.toml` menu:Cargotoml[package > name]. Package name does not have to be the name of the project.

[source, rust]
----
// lib.rs in "hello/src" directory
pub fn greet(){ // pub makes this function public
    println!("Hello Sam!");
}
----
[source, rust]
----
// main.rs in "hello/src" directory
use hello::greet; // similar to 'import' in Python

fn main(){
    greet(); // you could say "hello::greet();" without "use" 
}
----

:stdlib: https://doc.rust-lang.org/std/
:crates: https://crates.io/crates/rand
* Rust standard library `std` is very useful e.g. `use std::collections::HashMap`. Check {stdlib}[the documentation].

* If you need something that is not in the `std` lib, say random, you can add it by getting its name from menu:Crates[random package] {crates}[crates' random package] and then write its name in the `Cargo.toml` under dependencies. e.g. `rand =
"0.8.5"`. You can then generate random numbers.

[source, rust]
----
use rand::Rng;

fn main() {
    let mut rnd_no = rand::thread_rng();
    println!("Random number\t {}", rnd_no.gen_range(10..100));
}
----

== Scalar Types 

* Integers, floats, booleans, and characters (primitive types in JavaScript*).
* Unsigned integers starts with `u` followed the number of bits the integer has. e.g. `u16` Except for `usize` which specifies a pointer type. You use `usize` to index turples*. Signed integers, `i`, are the same except they use `i`.
* If you don't specify the type, it defaults to `i32` since it is generally the fastest even on 64 bit architectures.
* Not all types are supported by all architectures. A 16 bit microcontroller may not support 64 bit types. 
* Decimals are usual numbers, hexadecimals begin with `0x...`, Octal begin with `0o...`, binary with `0b...`, and bytes/u8 with `b'..'`. Underscores might be used wherever we like but they are ignored. e.g. `0xbunny = 0x_bunny = 0x_bunny_`.
* The following three ways to initialize x and y are the same.

[source, rust]
----
let x: u16 = 5;
let y: f32 = 3.14;
----
[source, rust]
----
let x = 5u16;
let y = 3.14f32;
----
[source, rust]
----
let x = 5_u16;
let y = 3.14_f32;
----
* Booleans are lower case `true` or `false`.
* Character type `char` could represent anything from alphabets, to emoji, to a chinese kanji, ... A character is always 4 bytes (32 bits), a `UCS-4/UTF-32` string. 

[source, rust]
----
let letta = 'h';
----

== Compound Types
:tuple: https://doc.rust-lang.org/std/primitive.tuple.html 
* Gather multiple values of other types into one type. e.g. {tuple}[#Tuple#] 

[source, rust]
----
let info = (1, 3.3. 999);
----
[source, rust]
----
let info: (u8, f64, i32) = (1, 3.3. 999);
----
* To access members of a tuple, use the `dot syntax` also known as a __field access expression__.

[source, rust]
----
let info = (3, 7.3, 966);
let bunny1 = info.0;
let bunny2 = info.2;
----

* You can also access members of a tuple all at once.

[source, rust]
----
let info = (3, 7.3, 966);
let (bunny1, bunny2, bunny3) = info;
----

* Tuple may have a limitation of 12 types e.g. 4 types ~ `(u8, u8, i32, u64)`

:arrays: https://doc.rust-lang.org/std/primitive.array.html 
* {arrays}[#Arrays#] store multiple values of the *same* type. 

[source, rust]
----
let bunny = [1,2,3]; // specifying literally
let bunny = [0;3]; // a value and how many you want
let bunny: [u8;3] = [1,2,3]; // specifying type - use semicolon form
----
* Arrays are indexed with square brackets. e.g. `bunny[1] = 2`
* Arrays are limited to size 32 above which they lose most of their functionality. Arrays live on the stack in a fixed size. You usually use vectors `Vec` or slices of vectors instead of arrays. 

== Control Flow 

* If expression - returns a value.

[source, rust]
----
if num == 5 {
    msg = "bunnies";
} else if num == 4 {
    msg = "bunny";
} else {
    msg = "sth";
}
----
* The condition is anything between `if` and `{` and must evaluate to a boolean.
* Rust doesn't like type coercion.

[quote, Type conversion, https://en.wikipedia.org/wiki/Type_conversion]
In computer science, type conversion, type casting, type coercion, and type juggling are different ways of changing an expression from one data type to another.

* If statement - don't return a value.

[source, rust]
----
msg = if num == 5 {
    "bunnies"       // same type
} else if num == 4 {
    "bunny"
} else {
    "sth"
};                  // only one ';' at the end

// short `if` expression
num = if a{b} else {c};
----

* Unconditional `loop {}`
* Conditional `loop {break;}`
* To `break` out of a nested loop, first annotate the loop you want to break out of with some label (also called tick identifier), say, `'sth` then tell break which loop you want to break out of. `continue` is similar.

[source, rust]
----
'sth: loop{
    loop {
        loop{
            break 'sth; // I want to break out of 'sth
        }
    }
}
----

* `while` loops 

[source, rust]
----
while bunny(){
    // do sth
}
----

[source, rust]
----
// similar to while loop
loop{
    if !bunny(){break}
    // do sth
}
----

* There is no `do while` in rust but you can make one.

[source, rust]
----
loop{
    // do sth
    if !bunny(){break}
}
----

* Rust `for` loop iterate over any iterable value.

[source, rust]
----
for num in [2,5,3].iter(){
    // do sth
}

// for loop can take a pattern
let array = [(1,2), (3,4)];
for (x,y) in array.iter(){
    // do sth with x and y
}

// ranges
for num in 0..10{
    // do sth in range 0 to 10. 
    // It will count 0-9 the end is exclusive. Like Python
    // To make the end inclusive, use `0..=10`
}
----

