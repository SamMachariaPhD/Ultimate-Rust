= Rust Fundamentals
Notes
:toc: auto

== Introduction 

* Fundamentals are important in rust.
* System programming language.
* Good for `Safety`, `Concurrency`, and `Speed`.

[quote, Wikipedia CONCURRENCY, https://en.wikipedia.org/wiki/Concurrency_(computer_science)]
In computer science, #concurrency# is the ability of different parts or units of a program, algorithm, or problem to be executed out-of-order or in partial order, without affecting the final outcome.

* `Python` can give you safety but not concurrency or speed.
* `C/C++` will give you speed and some concurrency but not safety.

https://github.com/CleanCut/ultimate_rust_crash_course [Github repo for exercises]

== Cargo 

* `Cargo` is a #package manager# for `Rust`. It is used to #search# for, #install# and manage packages that you want to use. It is also a #build system#, the #test runner#, and the #documentation generator#. Similar to _npn_, _pip_, and _make_.

* If you want to quickly create a project called *hello*, you can use the following command: `$ cargo new hello`. When you do `$ tree --noreport hello`, you will notice that the project has been created successfully. A config file `Cargo.toml` and a sorce directory `src` with the RUST `main.rs` file.

[plantuml, format=svg, opts="inline"]
----
hello
|_ Cargo.toml
|_ src
    |_ main.rs
----

[quote, Wikipedia TOML, https://en.wikipedia.org/wiki/TOML]
The name "TOML" is an acronym for "Tom's Obvious, Minimal Language" referring to its creator, Tom Preston-Werner.
TOML is a file format for configuration files. It is intended to be easy to read and write due to obvious semantics which aim to be "minimal", and is designed to map unambiguously to a dictionary. Its specification is open-source, and receives community contributions.

* Build and run your project by running `$ cargo run` within the `<...>.rs` folder. Results stored in `target/debug/hello`.

* It's a lot faster to compile* without debug: `$ cargo run --release`. Results stored in `target/release/hello`

== Variables 

* They start with `let`:

[source, rust]
----
fn main() {
    let bunnies = 2;
}
----

Assigning the type. e.g. 32 bit integer:

[source, rust]
----
fn main() {
    let bunnies: i32 = 4;
}
----

Initializing multiple statements at once: 

[source, rust]
----
fn main() {
    let (bunnies, carrots) = (2, 4);
}
----

* For safety, concurrency, and speed, Rust variables are immutable by default. Unless you chose to make them mutable so that you may change their values later. 
Data that never changes can be shared between multiple threads without loss [pass:q[<u>safety</u>]]. Compiler can do extra optimization on data it knows wont change [pass:q[<u>concurrency</u>]]. Run time can be improved by working with unchanging data [pass:q[<u>speed</u>]].

* To make the value of a variable mutable, add a key word `mut` e.g. 
[source, rust]
----
fn main() {
    let mut bunnies = 2;
    bunnies = 3;
}
----

* If you try to change the value of `bunnies` without making it mutable, you will get an error. Rust error messages are very relevant and helpful. Take time to read through an error message.

* Constants `const` are immutable and stay that way. They are usually in caps aka snake case e.g. `CONST_COEFF`. The type anotation is required e.g. `f64`.  The value must be constant expression that can be determined at compile time. e.g. 
[source, rust]
----
fn main() {
    const BUNNY_FACT: f64 = 4.2;
}
----

* You can place a cont outside a function and use it anywhere you want (global). This is good practice for speed.

== Scope 

* Variables have a scope. This is a place in the code within which they are accessible for use. 
* Variables are accessible within the blocks `{}` they were created in, or everywhere if they were created outside a function braces `{}`.
* Variables can be shadowed. You can have the same name with different initialization variables but in different scopes. e.g.
[source, rust]
----
fn main() {
    const BUNNY_FACT: f64 = 4.2;
}
----